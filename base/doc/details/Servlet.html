<html>
<head>
<title>Cougaar Servlets</title>
</head>
<body bgcolor="white">
<p>
<center><h1>Cougaar Servlets</h1></center>
<p>
These notes introduce the Cougaar Servlet support.
<p>
<ol>

<li>
See the webserver doc for installation and testing notes:<br>
<a href="../../webserver/doc/install.html"
>webserver/doc/install.html</a>.<br>
It will walk you through:
<ul>
  <li>optionally changing the HTTP port (8800 by default),
      optionally turning on HTTPS (typically port 8400),
      and other configuration details.</li>
  <li>loading the existing servlets (such as the "/tasks" servlet)</li>
  <li>running and testing the servlets</li>
</ul>
</li><p>

<li>
On Internet Explorer you should disable the
"friendly HTML error page" option:
<pre>
  tools-&gt;Internet Options-&gt;Advanced-&gt;Show Friendly HTTP error messages == UNCHECKED
</pre>
otherwise some helpful "no such path" error response messages will
be hidden by your browser.
</li><p>

<li>
There are a handful of built-in servlets that are always loaded.  These
are useful for both general users and developers.
<p>
The examples below assume:
<ul>
  <li>Host "localhost" is running a cougaar node with HTTP support
      on port 8800.</li>
  <li>On "localhost:8800" there's an agent named "foo".</li>
  <li>Agent "foo" has an internally registered (user-developed)
      servlet with path "/hello".  See the example section below
      for a sample "HelloServlet" implementation.</li>
  <li>There's no agent named "junk" in the society.</li>
  <li>Suppose that there's a second cougaar node on host "x.com"
      and HTTP port 9876.</li>
</ul>
<p>
Here are the built-in servlets:
<ul>
  <li><a href="http://localhost:8800">http://localhost:8800</a><br>
      <a href="http://localhost:8800/">http://localhost:8800/</a><br>
      Generate a simple help page, plus links to some of the
      built-in servlets listed below.<br>
      This is the best place to start.
    </li><p>
  <li><a href="http://localhost:8800/agents"
       >http://localhost:8800/agents</a><br>
      List agent names.  This servlet supports any combination of
      these URL-parameters:
      <ul>
        <li>"?local" -- list local agent names (default)</li>
        <li>"?all"   -- list all agent names (instead of "?local")</li>
        <li>"?html"  -- generate a pretty html page (default) </li>
        <li>"?text"  -- generate plain text, one name per line
                        (instead of "?html")</li>
      </ul>
      For example, 
      <a href="http://localhost:8800/agents?all&amp;text"
      >http://localhost:8800/agents?all&amp;text</a>
      will generate a plain-text listing of all agent names in the 
      society.
      <p>
      More precisely, the "?all" option will list all
      <i>web-registered</i> agents in the society, so if some agents
      in a society have HTTP/HTTPS disabled (via the "-D" properties
      described in the 
      <a href="../../webserver/doc/install.html"
      >webserver/doc/install.html</a>)
      then they will
      not be listed.  By default all nodes and agents are registered,
      so this is typically not an issue.
      </li><p>
   <li><a href="http://localhost:8800/$foo"
       >http://localhost:8800/$foo</a><br>
       <a href="http://localhost:8800/$foo"
       >http://localhost:8800/$foo/</a><br>
       Generate a help page for agent "foo", with a link to the
       "/$foo/list" servlet described below.
       </li><p>
   <li><a href="http://localhost:8800/$foo/list"
       >http://localhost:8800/$foo/list</a><br>
       List all the servlet paths registered on agent "foo".  In
       our example this should list:<ol>
         <li>/$foo/agents</li>
         <li>/$foo/hello</li>
         <li>/$foo/list</li>
       </ol>
       </li><p>
   <li><a href="http://localhost:8800/$foo/agents"
       >http://localhost:8800/$foo/agents</a><br>
       Run the "/agents" servlet on the node that is running agent 
       "foo".  This is handy for listing co-located agents.
       </li><p>
   <li><a href="http://localhost:8800/$foo/hello"
       >http://localhost:8800/$foo/hello</a><br>
       Invoke agent "foo"'s "/hello" servlet.  This is how all 
       user-developed servlets are invoked.
       </li><p>
   <li><a href="http://x.com:9876/$foo/hello"
       >http://x.com:9876/$foo/hello</a><br>
       This request to the wrong node is automatically redirected 
       to 
       <a href="http://localhost:8800/$foo/hello"
       >http://localhost:8800/$foo/hello</a>.
       In general a
       client can use any node's server as a "gateway" to
       all the agents in the distributed society and depend
       upon the built-in redirection to send the request
       to the right node.
       </li><p>
   <li><a href="http://localhost:8800/$/hello"
       >http://localhost:8800/$/hello</a><br>
       <a href="http://localhost:8800/hello"
       >http://localhost:8800/hello</a><br>
       This lets the node pick a <b>random</b> local agent
       and pass the "/hello" request to that agent.
       <p>
       This is only useful when you know (<i>a priori</i>) that
       all the agents have the same path registered and that they'll
       all generate an equivalent response.  For example, the "/tasks"
       servlet generates the same generic HTML frame no matter
       which agent it is started in.  The latter "/$/" is preferred,
       since it is more explicit that a random agent is being
       selected.
       </li><p>
   <li><a href="http://localhost:8800/$junk/hello"
       >http://localhost:8800/$junk/hello</a><br>
       This will generate an HTML error page with all local agent
       names and the "/hello" path tacked onto the end.  This
       is a bit of a hack, but can be used as a shortcut to calling
       "/agents" then typing one of the listed agent names and the
       "/hello".  Like the "/$/" above, this assumes that all the
       local agents have the "/hello" path registered.
       </li><p>
   <li><a href="http://localhost:8800/robots.txt"
       >http://localhost:8800/robots.txt</a><br>
       Generate this hard-coded response:<pre>
          User-agent: *
          Disallow: /
       </pre> which is used to exclude search engines, such as
       "google", from scanning cougaar web pages.
       </li><p>
</ul>
</li>

<li>
<a name="ini">
All user-developed servlets are loaded like plugins, with ".ini"-style 
"plugin = " lines.  There are also corresponding CSMART recipes that 
can be used.
<p>
Here's an example ".ini" line for loading the "/tasks" servlet:<pre>
   plugin = org.cougaar.core.servlet.SimpleServletComponent(org.cougaar.planning.servlet.PlanViewServlet, /tasks)
</pre>
</li><p>

<li>
For servlet developers, the standard Servlet API is used by the 
"ServletService".  You <i>don't</i> need to be an expert at the 
Servlet API to begin writing Cougaar Servlets, but here are some 
tutorials and reference documentation:
<ul>
  <li><a href=
  "http://java.sun.com/docs/books/tutorial/servlets"
  >Sun's Servlet tutorial</a></li>
  <li><a href=
  "http://www.apl.jhu.edu/~hall/java/Servlet-Tutorial"
  >Tutorial based upon the "Core Servlets" book</a></li>
  <li><a href=
  "http://www.novocode.com/doc/servlet-essentials"
  >Another good tutorial</a></li>
</ul>
The API includes methods for parsing URL parameters, reading passed data,
writing to the response output (text or data), etc.
</li><p>

<li>
<a name="api">
The ServletService API (with lots of javadocs) is in:
<br><tt>
&nbsp; core/src/org/cougaar/core/servlet/ServletService.java
</tt><br>
This defines the basic "register(servlet, path)" API.
</li><p>

<li>
There are several example servlets in the core's "examples"
directory:<br><tt>
&nbsp;  core/examples/org/cougaar/core/examples/servlet/*
</tt><br>
See the "README" in that directory for details.
<p>
The examples cover:<ul><p>
  <li>Use of the "SimpleServletComponent" to load non-cougaar
      servlets, such as the typical "Hello world!" servlet
      that is found in virtually all tutorials.</li><p>
  <li>Use of the SimpleServletComponent to provide the
      "SimpleServletSupport" API to the servlet, which
      makes it easy to write servlets that just need to:
      <ul>
        <li>know the agent's name</li>
        <li>query the blackboard</li>
        <li>know the names of all the agents in the society</li>
      </ul></li><p>
  <li>Extension of the "BaseServletComponent" class,
      which allows a servlet to access the full ServiceBroker
      and BindingSite capabilities.</li><p>
  <li>Use of the "raw" ServletService API, which allows
      any Component to register servlets.</li><p>
</ul>
Note that these example classes are not compiled into the 
"core.jar"; you'll need to compile them yourself.
<p>
Several PSPs have already been ported to servlets, such as
the port of the "/alpine/demo/TASKS.PSP" PSP
(<tt>org.cougaar.lib.planserver.psp.PSP_PlanView</tt>)
to the "/tasks" servlet
(<tt>org.cougaar.planning.servlet.PlanViewServlet</tt>).
</li><p>

<li>
Here are some important notes on the use "GET v.s. POST v.s. PUT" as 
the HTTP request method:
<p>
HTML-generating servlets should only use "doGet(..)", where HTML 
"&lt;a hrefs=..&gt;" are the same as before, but HTML FORMs should 
look like: <pre>
  &lt;form method="GET" .. /&gt;  <i>not POST!</i>
  ... <i>various "input" and "select" statements</i>
  &lt;/form&gt;
</pre>
<p>
Java clients that simply use URL-parameters can without writing
to the servlet can remain as-is, since HTTP GET works fine.
Java clients that need to upload data to the servlet, such as 
serialized Java Objects or a streamed 'dialog', should use PUT
instead of the default POST method: <pre>
   UrlConnection uc = ...;
   ((HttpUrlConnection) uc).setRequestMethod("PUT");
   OutputStream os = uc.getOutputStream();
   ...  <i>// usual "upload-data" code</i>
</pre> and the servlet should support the "doPut(..)" method.  Note
that the UrlConnection's setting of the "GET v.s. POST" method is 
not well documented in the Sun javadocs.
<p>
The reason for the above "use GET &amp; use PUT instead of POST"
nonsense is that POST requests will not be redirected between nodes
(typically the POST data is lost), whereas GET and PUT will be correctly
redirected.  The exact redirection rules are in the HTTP specification
and built into the browser/URLConnection code itself:
<ul>
  <li><a href=
  "http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html"
  >HTTP/1.1 spec on request methods</a></li>
  <li><a href=
  "http://ppewww.ph.gla.ac.uk/~flavell/www/post-redirect.html"
  >Further notes on POST redirection</a></li>
</ul>
</li><p>

<li>
There are a couple important browser/client API change for PSP porters to
note: 
<ol><p>
<li>
All PSP classes (org.cougaar.lib.planserver.*) have been deprecated
and will be removed in a future release (likely 9.2).  See
<a href=
"https://www.alpine.bbn.com/bugzilla/show_bug.cgi?id=1017"
>bug 1017</a>
.
</li><p>
<li>
The "default.psps.xml" file is now ignored.  All servlets are loaded
like plugins, with ".ini" lines or equivalent CSMART recipies.
</li><p>
<li>
See the "GET v.s.POST v.s. PUT" notes listed above.  All PSPs
that generate HTML FORMs must be modified to use "GET" instead of
"POST".  All Java-based clients that upload binary data to their
PSP must be modified to use "PUT" instead of the default "POST".
</li><p>
<li>
Lastly, the old PSP-server's URL parameter separator has been 
fixed from:<br>
&nbsp;&nbsp;<tt>  url?arg1=val1?arg2=val2?arg3=val3</tt> <br>
to the HTTP/1.1 compliant:<br>
&nbsp;&nbsp;<tt>  url?arg1=val1&amp;arg2=val2&amp;arg3=val3</tt> <br>
See
<a href=
"https://www.alpine.bbn.com/bugzilla/show_bug.cgi?id=20"
>bug 20</a>.  In both the client code and the ported PSP this URL
parameter-passing must be modified to match.  Typically this can
easily be done by skimming the code for uses of "?".
</li><p>
</ol>
Other than the changes listed above, the existing browser/user API is the
same for both PSPs and servlets.  You can pass the same URL parameters
and/or data-structures as before, and the internal logic can remain
exactly the same.
</li><p>

</ol>
</body></html>
