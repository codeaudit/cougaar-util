<html>
<head><title>Guidelines for Persistence and Mobility</title></head>
<body bgcolor="white">
<h2>Guidelines for Persistence and Mobility</h2>
<p>
It's important for components to be persistable and correctly rehydrate.  This is crucial both for agent restarts after JVM crashes and for agent mobility.
<p>
Below is a summary the issues and some simple tests that <b><i>ALL</i></b> Cougaar developers should run.
<p>
<hr>
<p>
<h3>Definitions:</h3><p>
<i>(Additional definitions are in the Cougaar Developer's Guide)</i>
<dl>
<dt>Agent restart</dt>
<dd>is when a dead (not running) agent is recreated on either the same or a different node, using a prior state snapshot if it is available.
</dd><p>
<dt>Persistence</dt>
<dd>is the infrastructure mechanism for taking periodic snapshots of the blackboard contents and saving these snapshots to the disk or other storage targets.  All blackboard objects must be serializable, and plugins must save their state in the blackboard or be able to recreate it from scratch.  <b>Note</b> that the plugin instances, services, and threads are not captured in the persisted state.  Persistence must be enabled by a system property, and the default storage target is the local filesystem.
</dd><p>
<dt>Rehydration</dt>
<dd>is the process of restarting an agent. It includes locating the most recent persistence snapshot, recreation of the blackboard, refilling the subscriptions, and reconciliation with other agents.  Ideally the snapshot was taken just prior to the agent's death, but components must support partial or complete loss of these snapshots.
</dd><p>
<dt>Lazy persistence</dt>
<dd>is the persistence mode that cougaar typically uses.  It takes a snapshot every couple minutes or so, and doesn't block agent messaging.  Lazy persistence risks some loss of state between snapshots, which means that some work may need to be reprocessed after restarts.  However, given that crashes are typically rare, lazy persistence obtains better overall performance and is more robust to state loss.
</dd><p>
<dt>Reconciliation</dt>
<dd>is the agent restart processing that is performed by lazy persistence to compensate for the periodic snapshots.  Agents communicate between one another to fill in state that was lost between the time of the snapshot and the agent death.  Reconcilliation and agent restart detection is done in the infrastructure (SimpleAgent's "checkRestarts()") and Logic Providers.  Plugins and other components typically don't need to be involved, except for the persistence and rehydration requirements of their own agent, as described below.
</dd><p>
<dt>Agent mobility</dt>
<dd>is the infrastructure mechanism to transfer a running agent from one node to another node.   Mobility uses persistence to capture the state, but unlike lazy persistence, mobility captures the state just prior to the move to avoid loss of state and (in 9.4) reconciliation.   Unlike regular persistence, components must unload and release all memory and threads to prevent resource leaks, since the node and JVM are not killed when an agent moves.  Note that nodes and node-agents are not movable.
</dd><p>
<dt>Forced move-based restart</dt>
<dd>is the use of agent mobility to restart an agent on its current node.  Typically a move request to the current node would be a trivial success, but in this case the full restart is forced.  As noted above, nodes and node-agents are not mobile, so node restart testing should use JVM-kills instead of mobility.
</dd><p>
</dl>
<p>
Additional details on lazy persistence and reconciliation are included <a href="#details">below</a>.
<p>
<hr>
<p>
<h3>Failure Examples</h3>
<p>
Failure to support persistence or unloading can produce runtime bugs and a major or subtle loss of capabilities.
<p>
Here are 5 examples that illustrate various failures:
<ol>
<li>
Suppose a plugin keeps an instance variables that is a count of the number of Tasks it has processed.  Since this variable is not in the blackboard, it won't be captured in the persistence snapshots.  Upon agent restart the counter is lost, which might result in a runtime exception, or worse: a very subtle runtime bug.
<p>
The fix is for the plugin to keep a blackboard object with this counter, and always "publishChange" this object when the counter is incremented, or to somehow recreate this counter based upon the existing blackboard contents (i.e. the counter is really a cache).
<p>
This is the cause for most rehydration errors.  The worst aspect of this bug is that it remains hidden until persistence or mobility are tested, at which time the agent is rehydrated but no longer functions.
<p>
Cougaar developers should build persistence support into their plugins as early in their design as possible and run the tests that are listed later in this document.
<p>
This bug is both a persistence bug, since the state was not captured, and a rehydration bug, since the plugin didn't attempt to recreate its cache within "setupSubscriptions()".
</li><p>
<li>
Suppose that a blackboard object is not serializable.  Persistence will be unable to take a snapshot of the blackboard, resulting in a runtime exception.  Note that the message transport doesn't serialize objects that are transferred between agents on the same node, so this problem can also creep in if formerly colocated agents are moved to separate nodes!
<p>
All blackboard objects must be serializable, or marked as non-persistent by overriding the Publishable API's "boolean isPersistable()" method.
</li><p>
<li>
Suppose that a plugin supports persistence and rehydration, but upon rehydration it rushes to redo lots of processing.  This may overload the system, consume too much memory, and accidently kill the JVM.
<p>
Agents should be careful not to overload the system when rehydrating.  In some cases plugins may need to buffer the work and use alarms.  Note that this is a general problem of work overload that may be exacerbated by rehydration.
</li><p>
<li>
Suppose that a plugin doesn't release all the resource in its "unload()" it has acquired in its "load()" or during execution.  These resources include:<ul>
  <li>Services</li>
  <li>Back-pointers from service providers (e.g. a blackboard subscription listener)</li>
  <li>Objects referenced by static fields</li>
  <li>Popup UIs</li>
  <li>Threads and Timers</li>
  <li>I/O and database connections</li>
</ul>
When the agent is moved these resources will not be returned to the JVM, resulting in resource leaks.
<p>
Also watch out for service revocation listeners (bugs 725 and 1549).
<p>
All components must support the "suspend()" and "unload()" operations.  In some cases a profiler (e.g. "OptimizeIt") must be used to check for resource leaks.
</li><p>
<li>
Suppose that a plugin communicates with a database to modify the database contents, or interacts with any other external system (writes files, RMI, etc).   Persistence is only periodic and "lazy", so upon agent restart these external resources can be out of sync with the rehydrated agent's state.
<p>
Cougaar blackboards include built-in reconciliation support, which is covered at the <a href="#details">end of this document</a>.
<p>
If one is lucky and the persistence snapshots coincide with the external activities, nothing will be lost.  Since a node may crash at any moment, due to power loss or other actions beyond the node's control, this clean external synchronization may not be possible.
<p>
To fix these interactions with external systems, your code needs to perform its own reconciliation procedure.  It must identify what was previously planned but will no longer be done, undo what will not be done, and recreate actions (e.g new Tasks) to correspond with plans that should be kept but were lost.  This can be very tricky to do correctly.
<p>
Some implementations may discard all external plans to keep things simple, which may be wasteful.
</li><p>
</ol>
<p>
<hr>
<p>
<h3>Tests</h3><p>
Below are 4 tests that developers can use to help verify that their components can support persistence and agent mobility.
<p>
First, some Cougaar 9.2 bugs and limitations to avoid:
<ol>
<li>
The node running the name server should not be killed, since the name server state will be lost and reconciliation will not occur.  This will not be fixed in Cougaar 9.4, but in a later release TBA (10.0+).
</li><p>
<li>
Not all agents and plugins support persistence.  In particular, the inventory management agents are not persistable or movable, due to state-capture bugs.
</li><p>
<li>
The known mobility bugs to watch out for, which will be fixed in 9.4, are:<ul>
  <li>Bug 1218: Don't try to move an agent to a non-existant destination node.</li>
  <li>Bug 1369: Don't request a move of an agent that is just loading or working on a move; wait a couple seconds.</li>
</ul>
</li><p>
</ol>
<p>
Here are the tests:
<ol>
<li>
If you're writing plugins that communicate between agents, make sure that the agents can run when split up between multiple nodes.  This will detect message serialization bugs, memory usage bugs, and any dependencies upon local resource (files, system properties, statics, etc).
<p>
For example, given 2 nodes and 6 agents named "a" through "f", a full split
requires <tt>&lceil;log2(6)&rceil;=3</tt> trials:<pre>
  [[[a, b, c, d], [e, f]],  <font color=blue>// first trial</font>
   [[a, b, e, f], [c, d]],  <font color=blue>// second trial</font>
   [[a, c, e], [b, d, f]]]  <font color=blue>// final trial</font>
</pre>
<p>
Here's a rough proof of how N nodes can split A agents using only
<tt>&lceil;logN(A)&rceil;</tt> trials:<p>
<!-- hack to indent: -->
<table border="0" width=*><tr><td width="10" valign="top">&nbsp;</td><td width=* valign="top">
Assume N = 2, so we can use simple binary reasoning.  Create a trial for 
each of the log2(A) bits and, for each trial <i>i</i>, split the list 
into one of two groups ("0" and "1") based upon the bit at index <i>i</i>.
For any two indices in the list, their binary representation differs by 
at least one bit <i>x</i>, so they will be split into different groups 
on trial <i>x</i>.  A similar proof can be made for any value of N by 
using base-N arithmetic.
<!-- end indent hack -->
</td></tr></table> 
<p> Here's some example Java code that can be used to help create your ".ini" files:
<pre>
  <font color=blue>/** Given a number of <i>n</i> groups and a list of names,
   *  create a list of trials, where each trial is 
   *  a split of the original list into <i>n</i> sublists. */</font>
  public static List compute(int n, List a) {
    <font color=blue>// validate</font>
    if ((n &lt; 2) || (a == null) || (a.isEmpty()))
      throw new IllegalArgumentException("n: "+n+", a: "+a);
    <font color=blue>// compute max digits in base n</font>
    int m = (int) Math.ceil(Math.log(a.size()) / Math.log(n));
    if (m == 0) m = 1;
    <font color=blue>// alloc results list of size [m][m][m]</font>
    List ret = new ArrayList(m);
    for (int i = 0; i &lt; m; i++) {
      List x = new ArrayList(m);
      ret.add(x);
      for (int j = 0; j &lt; m; j++)
        x.add(new ArrayList(m)); <font color=blue>// average size is m, max is n</font>
    }
    <font color=blue>// split based upon values in base n</font>
    for (int i = 0; i &lt; a.size(); i++) {
      String ai = (String) a.get(i);
      for (int j = m - 1, t = i; j &gt;= 0; j--, t /= n) {
        ((List) ((List) ret.get(j)).get(t % n)).add(ai);
      }
    }
    return ret;
  }
</pre>

</li><p>
<li>
Persistence can be enabled with a system property:<pre>
  -Dorg.cougaar.core.persistence.enable=true
</pre>
When running the node you'll see occasional "P" characters printed to standard-out, indicating that persistence is taking place.
<p>
To test, simply kill the node with a CTRL-C, and start the node again.  This can also be done from within CSMART, by using the Node window's Control menu from within the CSMART Console to either "Kill" or "Restart a Node".
<p>
Note: Don't kill the node running the name server, since in Cougaar 9.X it does not support persistence.  The name server is launched on the first node to start on the machine specified by the "configs/common/alpreg.ini" file (default is localhost), or as specified through CSMART's "-Dorg.cougaar.name.server=.." system property.
<p>
Use the "/tasks" servlet to make sure that the agents are recreated and the blackboard is rehydrated.
<p>
The real test is to submit additional work for your plugins to do, to make sure that they have restarted correctly -- recall the above "plugin counter" example listed above.
<p>
The first test should be:<ol>
  <li>send GLS</li>
  <li>wait until processing is complete</li>
  <li>wait for a bunch of "P"s</li>
  <li>kill all nodes</li>
  <li>restart all nodes</li>
  <li>rescind GLS</li>
</ol>
<p>
Additional tests should include:<p>
<ul>
<li>
Submit additional work for the agents to do after restarting.  In some
societies the GLMStimulator servlet can be used to inject new Tasks.
</li><p>
<li>
Kill a subset of the nodes.
</li><p>
<li>
Kill a node in between the "P"s, since a crash could happen at any time.
</li><p>
<li>
Kill and restart a node while the GLS processing is in progress.
</li><p>
<li>
Remove the persistence snapshots for one or more agents.  The snapshots are typically saved in the "$COUGAAR_WORKSPACE/P", where COUGAAR_WORKSPACE defaults to "$COUGAAR_INSTALL_PATH/workspace".  Restart the node and make sure that your agents have rehydrated even if state is lost.
</li><p>
</ul>
<p>
Clearly, all permutations of the above tests would take a long time.  Try a few tests at random to flush out the easier bugs.  Focus on scenarios that your application might encounter.
<p>
Testing of state loss and reconciliation requires some level of JVM-kill testing.  Mobility testing is somewhat easier, but mobility uses a clean persistence snapshot to avoid the reconciliation overhead.  This means that some agent may be mobile but incapable of restarting after a node crash, so be sure to test both scenarios.  Additionally, nodes and node-agents are not movable, so a JVM-kill must be used to test the persistence and rehydration capabilities of the node and node-agent.
<p>
Also note that reconciliation behaves differently for the sender and receiver of Tasks, which means that the restart of the root node of task processing (e.g. NCA) is different than the restart of a leaf agent (e.g. ConusGround).
<p>
Scripted persistence testing may be added in the post-9.4 future.
</li><p>
<li>
Agent mobility supports an in-place "forced" move of an agent, which does:<ol>
   <li>capture the agent state using an in-memory persistence snapshot</li>
   <li>unload and kill the agent</li>
   <li>rehydrate the agent from the in-memory snapshot</li></ol>
The restart can be requested from either the "/move" servlet or from a plugin.
<p>
Mobility support must be explicitly added to the agent configuration.  CSMART includes mobility support by default in all experiments.
<p>
Non-CSMART (".ini") societies require these configuration steps:<p>
<ol>
<li>
Persistence does not need to be enabled.
</li><p>
<li>
The mobility domain can be loaded by added this line to the "LDMDomains.ini" file, which is located in the "$COUGAAR_INSTALL_PATH/configs/common" directory:<pre>
  mobility=org.cougaar.core.mobility.ldm.MobilityDomain
</pre>
</li><p>
<li>
Add this plugin to all nodes:<pre>
  plugin = org.cougaar.core.mobility.service.RootMobilityPlugin
</pre>
</li><p>
<li>
The following plugins should be loaded in the agent to be restarted, and can be safely loaded into all agents:<pre>
  plugin = org.cougaar.core.mobility.service.RedirectMovePlugin
  plugin = org.cougaar.core.mobility.servlet.MoveAgentServlet
</pre>
Additionally add this line to enable the "/topology" servlet, which can be used to see which agents are loaded and which node they are running on:
<pre>
  plugin = org.cougaar.core.topology.TopologyReaderServlet
</pre>
</li><p>
<li>
The logging level can be optionally be adjusted to capture additional mobility debugging output.  This system property specifies the logging configuration file, which can be named "$COUGAAR_INSTALL_PATH/configs/common/log.props":<pre>
  -Dorg.cougaar.core.logging.config.filename=log.props
</pre>
and the file contents below will enable verbose output:<pre>
  log4j.rootCategory=WARN,A1
  log4j.appender.A1=org.apache.log4j.ConsoleAppender
  log4j.appender.A1.layout=org.apache.log4j.PatternLayout
  log4j.appender.A1.layout.ConversionPattern==%d{ABSOLUTE} %-5p - %c{1} - %m%n
  log4j.category.org.cougaar.core.mobility=DEBUG
</pre>
See the "$COUGAAR_INSTALL_PATH/doc/details/Logging.html" for additional logger configuration options.
</li><p>
</ol>
<p>
Suppose that you want to test agent restart on agent "X".  Here is the test procedure:<p>
<ol>
<li>Follow the above instructions to load the three plugins and domain.</li><p>
<li>Start the society.</li><p>
<li>Assuming that a node is running on localhost port 8800, use a browser to load this URL:<pre>
  http://localhost:8800/$X/topology
</pre>
The topology should list agent X on it's starting node.  Write down the incarnation and move-id numbers.
</li><p>
<li>
Access this URL:<pre>
  http://localhost:8800/$X/move
</pre>
An HTML form is presented to submit a new move request.  Fill in the details as:
<table border=1>
<tr><td>Mobile Agent</td><td>X</td></tr>
<tr><td>Origin Node</td><td>&nbsp;</td></tr>
<tr><td>Destination Node</td><td>&nbsp;</td></tr>
<tr><td>Force Restart</td><td>true</td></tr>
</table>
Note the "true" selection for the force restart option.  By default the restart will produce a trivial "success" response, since the agent is already at it's current node.
<p>
Select "Add", and the move-based restart is submitted.
</li><p>
<li>
The "/move" servlet will refresh and display a table of pending moves, where the current move request will have a <i>null</i> status.  Select the "Refresh" button (<b><i>not</i></b> Reload!) to update the page.  Eventually the table will show the status as non-null, with either a success or failure value.
</li><p>
<li>
Access the "/agents" servlet, and make sure that the agent is still listed in the "list all" view.
</li><p>
<li>
Access the "/topology" servlet again to verify that the agent has been reloaded, that the incarnation number is the same, and that the move-id number is now larger than the prior move-id number.
</li><p>
<li>
Submit additional work for the agent to process, to verify that the plugins have rehydrated correctly.  The GLM-Stimulator-Servlet can be used to submit additional transportation tasks.  Depending upon your application, a custom tool may be required.
</li><p>
</ol>
<p>
Also try the above test from a third-party agent, which also requires the above plugins and mobility domain.  For example, from agent X, request that agent Y be restarted in place.
<p>
In 9.4 there will be some mobility-related bug fixes and a scriptable mobility test rig.  For 9.2 the above servlet can be used.
</li><p>
<li>
Also use the "/move" servlet to move multiple agents to and from nodes.  The configuration requirements to load the "/move" servlet, mobility domain, and MoveAgentPlugin are the same as listed above.
<p>
Usage is similar to the above test.  Fill in a non-blank destination node in the "/move" servlet form.
<p>
A good test is to create an empty node and move all agents from an existing node to that empty node.  The "/agents" and "/topology" servlets should show the original node as empty (see doc/details/Servlet.html).  A profiler, such as "OptimizeIt", should show the original node as mostly empty, with little memory and threads in use.   Kill the original node, submit addition work to the agents, and verify that the moved agents still work.
</li><p>
</ol>
<p>
<hr>
<a name="details">
<p>
<h3>Details</h3>
<p>
Here's an in-depth summary of how lazy persistence and reconciliation work:<p>
<!-- hack to indent: -->
<table border="0" width=*><tr><td width="10" valign="top">&nbsp;</td><td width=* valign="top">
<font size="+1">Lazy Persistence</font><br>
Cougaar persistence has been modified to operate in an optimistic or "lazy" mode. This mode is optimistic in that it assumes that restarts will not occur and that the persisted data is not absolutely essential. By making these two assumptions, the state of the agent can be saved much less frequently. This has the benefit that the objects to be saved will have had an opportunity to evolve through several stages and only their most recent stage will need to be saved. Lazy mode operates in the same way as non-lazy (or pessimistic) mode except the interactions with other agents are not rigidly locked into step with persistence. Instead, the states of an agent and the agents with which it interacts are allowed to progress without absolute assurance that the current state can be recovered in the event of a restart. The obvious upshot of this is that, if an agent is restarted, it will be in a state that is inconsistent with the states of the other agents with which it interacts. This inconsistency must be reconciled or else incorrect operation will ensue.
<p>
<font size="+1">Reconciliation Rationale</font><br>
The reconciliation process depends on intrinsic redundancy in Cougaar agent interactions. In all cases, these interactions are in terms of objects that are (logically) shared between the blackboards of the agents. Furthermore, this sharing comprises a master-slave relationship. A typical example is a task that has been allocated to another agent. A copy of the task is sent to that other agent when the allocation is first created and then updated copies are sent as changes are made to the source task.
<p>
These shared objects have a well-defined life cycle: they are created in an initial state, progress through a number of intermediate states and then are destroyed.
<p>
The destruction of a Task actually can signify two things: the plan has changed and the Task is no longer desired *OR* and time has progressed and the Task is no longer relevant. In the latter case, the agents should have already permanently factored the effect of the deleted task into their planning. The Task deletion process marks Tasks to distinguish these cases.
<p>
Note that there is *NO* semantic significance to the events that signal this progression, but the events do allow the agents to perform incremental updates. Since there is no significance to the path by which an object arrived in its current state (including its non-existence), the resynchronization process is not tasked with detailing these intermediate states; it need only insure that the slave object have the same state as the master.
<p>
In normal operation, the slave tracks the master because the message transport insures reliable, ordered delivery of the state changes. When a restart occurs, however, there are several opportunities for the slave and master states to diverge. The three most obvious are:<ol>
  <li>State changes sent just prior to the restart were not delivered.</li>
  <li>State changes received just prior to the restart were not persisted.</li>
  <li>The restarted agent has reverted to an earlier state of the object.</li></ol><br>
While there may be other ways for the states to diverge, the exact mechanism is not important. It is only important that agreement be restored between the master and slave copies.
<p>
Ideally, the state given by the copy that was not subject to restart would be used. However, this poses difficulties when that copy is the slave copy because the agent that had the master copy has lost the causal links leading to the value of the slave copy. (If the causal links were not lost the master and slave copies would still be equal.) Recovering these causal links is problematic and is not attempted.
<p>
<font size="+1">Reconciliation Procedure</font><br>
The resynchronization procedure occurs between pairs of agents as follows: Both agents must realize that a restart has occurred. The restarting agent knows this trivially. For another agent, it is more difficult. Currently, this is achieved by periodically checking the incarnation number of the agent in the naming service. This is less than ideal, but suffices for the moment.
<p>
The incarnation numbers are saved in the topology service, which is backed by the global naming service.  Agents increment their incarnation number every time the agent is restarted, <i>except</i> for agent mobility, which keeps the prior incarnation number.  A secondard "move number" is kept to track agent movement, which is initialized to the incarnation number when the agent is first created and incremented per move.
<p>
These incarnation numbers are available from the TopologyReaderService and the "/topology" servlet, but are primarily for infrastructure use only.
<p>
Both agents perform the same resynchronization procedure though not necessarily at the same time. The procedure seeks to establish two invariants: all objects that an agent sent to another agent exist in that other agent with the same values and an agent has no object (Task, Transferable, etc.) received from another agent that does not exist in that other agent. To this end, each agent resends all the objects that it previously sent to the other agent and sends verification requests about all the objects it previously received from the other agent. If the resent objects are already present in the other agent, their values are updated and, if changed, a "change" event is processed. If the resent objects are not already present, they are added to the blackboard and an "add" event is processed. If a "verification" message refers to an object that is no longer on the blackboard, a "rescind" message is sent back just as if it had been removed from the blackboard. The rescind message is processed and removes the now spurious object. This handles two cases: the original "rescind" message was lost because the agent reverted to a state prior to receiving the "rescind" message and the other agent reverted to an earlier state prior to the creation of the task. In both cases, the task should not exist, so sending the "rescind" message is appropriate.
<p>
Every task that is removed from an agent that did not restart represents lost work. The restarted agent will ultimately create new tasks that will be equivalent to the lost tasks, but they will usually not be identical. This is "ok" because of the non-deterministic nature of Cougaar. Also, performing the reconciliation steps in a certain order can be more efficient than some other order. For example, ascertaining that an incoming task has been rescinded before re-sending the resultant tasks would avoid the effect on downstream agents of sending tasks and then almost immediately rescinding those same tasks. This optimization is not currently performed.
<p>
Correct operation of the reconciliation procedure (and Cougaar, in general) depends on ordered delivery of messages between agents. This is clear in the case of a succession of changes to an object. An earlier change arriving after later one will leave the object in the wrong state. When an agent restarts, it is essential that the other agents not receive messages from earlier incarnations of the restarted agent after beginning to receive messages from the new incarnation. This requirement is satisfied by the current message transports.
<!-- end indent hack -->
</td></tr></table> 
<p>
</body></html>
