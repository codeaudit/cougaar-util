<html>
<head><title>Cougaar Logging Service</title></head>
<body bgcolor=white>
<h2>Cougaar Logging Service</h2>
<p>
Cougaar provides a standardized logging service to all components.
<p>
This document covers:<ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#config">End-user configuration of the logger</a></li>
  <li><a href="#developer"
       >Developer use of the logging services</a></li>
  <li><a href="#statics">Developer notes on static logging</a></li>
</ul>
<hr>
<a name="overview">
<h2><b>Overview:</b></h2>
<p>
A shared logging service is used by Cougaar plugins, components, 
and service providers to capture debugging and error text.  The level 
of logging can be controlled at start-time and at run-time.  Third-party 
tools can be used to view and filter the logs.
<p>
Each log entry is tagged with the component's classname, timestamp, a 
description message, and a logging level.  There are 6 logging levels:
<pre>
   DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; SHOUT &lt; FATAL
</pre>
Application code (plugins) obtain a "LoggingService" and record their
separate log messages at these levels.
<p>
The user can specify the minimal log level for their debugging needs.
The default level is "WARN", which discards all "DEBUG" and "INFO"
logging statements.  The logging level can be configured for all 
components or on a per-package or per-class basis.
<hr>
<a name="config">
<h2><b>End-user configuration of the logger:</b></h2>
<p>
By default Cougaar will write all logging calls at WARN or
higher to system-out, in a form like:
<pre>
   2002-03-08 22:26:34,898 WARN [class] - message
</pre>
The output format, destination, and logging threshold can be 
configured at node creation time by setting "-D" system properties.
Currently these properties use log4j-style statements, and the underlying 
LoggingService implementation uses log4j.  Logging configuration 
can assume that log4j is in use.
<p>
The system properties are:
<ul>
  <li>"-Dorg.cougaar.core.logging.config.filename=FILE"<br>
      Specify a log4j property filename, which is found
      using the ConfigFinder.</li><p>
  <li>"-Dorg.cougaar.core.logging.NAME=VALUE<br>
      Pass the given "NAME=VALUE" to override the above FILE
      contents.</li>
</ul>
Note that if you use any of the above 
"-Dorg.cougaar.core.logging.*" properties then you <b>must</b> 
fully specify the logging configuration.
<p>
Here is a minimal log4j property file that matches the Cougaar
default logging configuration:
<pre>
  log4j.rootCategory=WARN,A1
  log4j.appender.A1=org.apache.log4j.ConsoleAppender
  log4j.appender.A1.layout=org.apache.log4j.PatternLayout
  log4j.appender.A1.layout.ConversionPattern==%d{ABSOLUTE} %-5p - %c{1} - %m%n
</pre>
<p>
Change the "WARN,A1" to a "DEBUG,A1" and you'll get lots of debugging
output from all the components.  Change the "WARN,A1" to "FATAL,A1"
and you'll see virtually zero logging output.
<p>
The logging level is set to a default level with the 
"log4j.rootCategory=.." line.  The level for individual packages can 
changed by adding "log4j.category.PACKAGE=LEVEL" lines, such as:
<pre>
  ...
  # set the level to "info" for all "org.cougaar.core.*" subpackages:
  log4j.category.org.cougaar.core=INFO
</pre>
This can be used to turn the level up or down from the root level.  As
noted above, logging levels are "inherited" down the package hierarchy.
The level can also be set for a specific class, which must be the
"service-requestor" that obtained the logging service:
<pre>
  ...
  # debug your "com.foo.MyPlugin":
  log4j.category.com.foo.MyPlugin=DEBUG
</pre>
In some cases you may need to specify the category name:
<pre>
  log4j.category.org.cougaar.core=INFO,A1
</pre>
<p>
One special level is cougaar-specific SHOUT, which must additionally 
specify the classname of the shout implementation:
<pre>
  log4j.category.com.foo.MyPlugin=SHOUT#org.cougaar.util.log.log4j.ShoutPriority
</pre>
Typically one only filters at ERROR or FATAL, so a reference to
SHOUT in a properties file is rarely used.
<p>
Additional documentation on log4j configuration is provided in
<a href="http://jakarta.apache.org/log4j/docs/manual.html"
>the log4j manual</a> and 
<a href="http://www.javaworld.com/javaworld/jw-11-2000/jw-1122-log4j_p.html"
>this additional overview</a>.
<p>
Log4j supports many open-source log appenders and log 
visualizers.  For example, log4j can be configured to stream
logging statements over sockets.  Log visualizers include
<a href="http://traxel.com/lumbermill">the lumbermill UI</a>.
<p>
Here is an example lumbermill ".props" file:
<pre>
  log4j.rootCategory=DEBUG,LogServer
  log4j.appender.LogServer=org.apache.log4j.net.SocketAppender
  log4j.appender.LogServer.Port=4445
  log4j.appender.LogServer.RemoteHost=127.0.0.1
</pre>
<p>
For Cougaar 9.0 there is minimal support to change logging 
levels and appenders at runtime.  The "LoggingControlService"
is overly limited, and will likely be redesigned in a future
Cougaar release.
<p>
Cougaar also has a non-service logging API, 
"org.cougaar.util.log", which can be used by external 
applications such as CSMART.
<p>
<hr>
<a name="developer">
<h2><b>Developer use of the logging services:</b></h2>
<p>
The logging support includes a "LoggingService", which is used by components
to append to the log, and configuration utilities to customize the logger:
set logging levels, set logging destinations, etc.
<p>
The LoggingService is the API used by component developers.  This service 
is obtained through the ServiceBroker, just like any other service -- see 
the Cougaar Developer Guide section on use of the ServiceBroker for further 
details.
<p>
Cougaar components should <u><b>NOT</b></u> directly access the
"org.cougaar.util.log" classes, such as the "LoggerFactory" or "Logger". 
The standard "LoggingService" should be used instead.  Third-party tools
may use the LoggerFactory for their non-Cougaar logging (e.g. CSMART).
<p>
For example, this is an easy way for a plugin to obtain the logger during
load-time:
<pre>
   import org.cougaar.core.service.LoggingService;
   ...
     private LoggingService log;
     public void setLoggingService(LoggingService log) {
       this.log = log;
     }
</pre>
<p>
This is equivalent:
<pre>
   import org.cougaar.core.service.LoggingService;
   ...
     private LoggingService log;
     public void load() {
       super.load();
       this.log = (LoggingService)
         serviceBroker.getService(
           this, LoggingService.class, null);
       ...
     }
</pre>
<p>
Currently a component can only obtain a log with its classname as the
log category name; i.e. log messages written by the component will be
identified by the component classname.
<p>
The LoggingService defines 6 logging levels:
<pre>
   DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; SHOUT &lt; FATAL
</pre>
and three generic methods:
<pre>
   /** @return true if the logger is enabled at the given level */
   public boolean isEnabledFor(int level);

   /** Append the given message to the log at the given level.  */
   public void log(int level, String message);

   /** Append both the given message and exception at the given level.  */
   public void log(int level, String message, Throwable t);
</pre>
plus there are short-cut methods for all the levels:
<pre>
   /** Equivalent to "isEnabledFor(DEBUG)" */
   public boolean isDebugEnabled();

   /** Equivalent to "log(DEBUG, message)" */
   public void debug(String message);

   /** Equivalent to "log(DEBUG, message, t)" */
   public void debug(String message, Throwable t);

   // ditto for all the other levels (isInfoEnabled(), etc)
</pre>
<p>
Here's an example use of the log:
<pre>
   ...
     if (log.isInfoEnabled()) {
       log.info("this is my message");
     }
</pre>
<p>
As noted above, all logging statements specify a logging level, and 
if the logger is configured at a level &gt;= to the specified 
level then the logging message is appended to the log.
<p>
A general guide to logging levels is:
<ul>
  <li>use DEBUG for code-level developer details that are
      just for code debugging</li>
  <li>use INFO for user-level "verbose" details that may be 
      of interest but can be ignored</li>
  <li>use WARN for user-level warnings that are important 
      but ignorable.  This is the default level for
      cougaar logging.</li>
  <li>use ERROR for significant problems (exceptions, etc)
      that can't be recovered from.  Log statements at
      ERROR or higher are rarely filtered out.</li>
  <li>use SHOUT for significant information messages that
      one would otherwise sent to standard-out, such as
      "Started node".  This level should only be used
      for occasional non-ignorable information messages.
      Most developers should consider using INFO instead.</li>
  <li>only use FATAL for violations of major assumptions</li>
</ul>
<p>
<u><b>MAKE SURE</b></u> to wrap all "log(..)" calls with the related
"is*Enabled(..)" check.  For example, use:
<pre>
   if (log.isDebugEnabled()) {
     log.debug("some message");  // good
   }
</pre>
instead of just using:
<pre>
   log.debug("some message");  // <b>wasteful!</b>
</pre>
This is most important when the log message requires the 
creation of a new String, such as:
<pre>
   log.debug("cons together "+this+" plus other args "+i+", etc");
</pre>
since the above string-creation will incur a runtime memory and
performance cost whether or not the logger is at the DEBUG 
level.  In practice this can be a significant performance 
penalty.
<p>
The LoggingService API is essentially a subset of the 
<a href="http://jakarta.apache.org/log4j">log4j</a> API, but the
LoggingService API itself is not compile-time dependent upon log4j.
In the future the underlying implemention may be modified to use
Sun's JSR47, so LoggingService clients shouldn't make log4j 
assumptions when using the LoggingService.
<p>
<hr>
<a name="statics">
<h2><b>Developer notes on static logging:</b></h2>
<p>
The LoggingService is only provided to Components (e.g. Plugins), which must 
have a reference to the agent's ServiceBroker.  Plugins themselves are never 
static, so each Plugin instance can hold onto its own LoggingService instance 
that was provided by its ServiceBroker.
<p>
The non-static nature of the LoggingService allows the infrastructure to 
control logging on a per-plugin or per-agent basis.  For example, if two 
agents are on the same node, the logger could have Binders to disable all 
logging for one agent and enable debug-level logging for the other agent.
<p>
One snag is the use of static classes for utility methods or library methods. 
 For example, consider this "modulus" utility method:<pre>
   public class MathUtilities {
     public static int mod(int number, int modulus) {
       if (b == 0) {
         System.err.println("Modulus must be non-zero!");
       }
       return (number % modulus);
     }
   }
</pre>
This method is called by some plugin, and we'd like to replace the 
"System.err.println(..)" with a "log.error(..)" call.  This requires access 
to an instance of the LoggingService.
<p>
There are about seven options for this conversion to the logging service.  
None of these options are pleasant:<ol>
<p>
<li>
The infrastructure could provide a static method to obtain the
LoggingService, which could be accessed by the utility method.
There are some security holes with this approach, plus important
information is lost (the id of the component / agent caller).   This
would require infrastructure work that is not planned at this time.
</li><p>
<li>
A static LoggingService variable can be kept that has a synchronized
"setter" method.   The first Plugin to execute is allowed to set this 
variable.   The big downside of this approach is that all logging output
based upon that static variable will be tagged by the first caller's
classname, plus it can backfire when Binders are used to disable
specific logging calls.
</li><p>
<li>
Pass along a LoggingService argument into the method:
public static int mod(int number, int modulus, LoggingService log) {..}
This is tedious to implement, and spreads like a stain throughout the
code.  Sometimes an aspect-orientated code rewriter can be used to 
automate this process (AspectJ).
</li><p>
<li>
Convert the method to non-static, and have a LoggingService field
in the outer class:<pre>
    public class MathUtilities {
        private LoggingService log;
        public class MathUtilities(LoggingService log) { this.log = log; }
        public int mod(int number, int modulus) { .. }
    }
</pre>
This requires the caller to create an instance of the class prior to
calling the method.   The caller can typically keep a field to hold
its instance of the class, to avoid repeated "new" caller per method call.
Like option (1), this can "create-an-instance"  requirement can spread 
throughout the code.
</li><p>
<li>
Similar to option (4), an adapter class can be written that keeps the
old API but uses a "null-logger", which will discard all logging output.  
For simplicity we'll rename our non-static class:<pre>
    public class MathHelper {
        private LoggingService log;
        public class MathHelper(LoggingService log) { this.log = log; }
        public int mod(int number, int modulus) { .. }
    }
</pre>
and use the original name for the adapter class:<pre>
    import org.cougaar.core.logging.NullLoggingServiceImpl;
    public class MathUtilities {
        // create dummy static instance:
        private static final MathHelper INSTANCE = 
            new MathHelper(
                NullLoggingServiceImpl.getNullLoggingServiceImpl());
        public static int mod(int number, int modulus) {
           return INSTANCE.mod(number, modulus);
        }
    }
</pre>
This design retains the old method signature but suppresses the 
logging in that case, so it's a bit of a compromise.
</li><p>
<li>
Use a ThreadLocal to save the LoggingService in a per-thread static
variable, which can later be picked up by the static utility method.
One class defines the ThreadLocal variable, the plugin sets the
variable prior to the method call, the static method accesses the
variable, and later on the plugin clears the variable.   The downside
of this approach is that it requires coordination between the plugin
and the static method, the ThreadLocal usage is a somewhat expensive
operation (HashMap access per use), and there's a security hole if
the plugin fails to clear the variable after use.
</li><p>
<li>
A combination of (5) and (6) is possible, where the "INSTANCE"
refers back to the ThreadLocal to get the LoggingService instance of
the caller.  Like (6), this requires special coordination on the part
of the caller.
</li><p>
</ol>
<p>
So which approach is best?<ol>
  <li>is currently not implemented.</li>
  <li>generates the incorrect output unless there can only be
      one instance of your caller, such as a node-level service.</li>
  <li>is painful to implement and ugly.</li>
  <li>is the cleanest if one is developing new code.</li>
  <li>is a half-way step to (4) if there are many clients of the 
       utility class.</li>
  <li>is hard to get right unless you have control over all the
       callers and can arrange this coordination.</li>
  <li>is similar to option (6) in complexity and deficiencies.</li>
</ol>
<p>
So either option (4) or (5) is recommended for most implementations.
</body>
</html>
