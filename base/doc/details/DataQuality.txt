// new basic interface for DataQuality with no specific API:
package org.cougaar.domain.planning.ldm.dq;
interface DataQuality {}
interface HasDataQuality {
  DataQuality getDataQuality();
}
interface NewHasDataQuality extends HasDataQuality {
  void setDataQuality(DataQuality dq);
}

// It is up to each Domain to decide what DataQuality means for
// its objects.  E.g.:

package org.cougaar.domain.glm.ldm;
interface ALPDataQuality extends DataQuality {
  // all the slots from the DQ proposal
  // ...
}

// added the following accessor to PropertyGroup:

interface PropertyGroup {
  // return true IFF this instanceof HasDataQuality and
  //  getDataQuality()!=null
  boolean hasDataQuality();
  //...
}

;; properties.def specifies which PGs to generate DQ variations.
;;  Default is true.

;; The default may be changed with a top-level on a per-props.def basis:
;; hasDataQuality=false

[FooPG]
hasDataQuality=false	// to turn it off
[BarPG]
hasDataQuality=true	// to turn it on (redundant)


// Generated PGs with DQ disabled implement PropertyGroup.hasDataQuality like:
class FooPGImpl {
  boolean hasDataQuality() { return false; }
}

// Generated PGs with DQ enabled implements two variations:

// unmarked would be without (runtime) DQ
// implements the getter API (HasDataQuality) but not the setter.
class BarPGImpl implements HasDataQuality {
  boolean PropertyGroup.hasDataQuality() {
    return false;
  }
  DataQuality getDataQuality() {
    return null;
  }
  void setDataQuality(DataQuality dq) {
    throw new RuntimeException();
  }
}

// marked would be with (runtime) DQ
class BarPGImpl.DQ extends BarPGImpl implements NewHasDataQuality {
  boolean hasDataQuality() {
    return (_dq != null);
  }

  private DataQuality _dq = null;
  DataQuality getDataQuality() {
    return _dq;
  }
  void setDataQuality(DataQuality dq) {
    _dq = dq;
  }
}

NullPG instances never have actual DQ, but they still implement the
appropriate interfaces to match.

DQ queries on FuturePGs always return immediately (they will not
block, unlike the actual getProperty() methods).  If the future is not 
finalized, the DQ is undefined (returns null).  When finalized, it
will return the DQ of the real PG instance.  This offers transparent
support of the pattern where a plugin gets some set of values from the 
PG (possibly blocking then) and then decides among several choices
based on DQ.

Locked instances would have the same DQ as the real one except without 
the setter.

DQ instances are persisted but are not sent between clusters because
the DQ information is (most likely) immediately wrong once sent.

When an LDM plugin wants to create a PG instance, it can now decide if 
it should attach DQ or not.  There is no overhead for the default
(non-DQ at runtime) case.
 
  // assuming that MyPG is DQ-enabled:

  // Cannot set DQ, but allows asking for DQ (always false/null):
  MyPG x = new MyPGImpl();
  boolean xdqp = x.hasDataQuality();    // always false
  DataQuality xdq = x.getDataQuality(); // always null

  // versus, Can set DQ:
  MyPG y = new MyPGImpl.DQ();
  DataQuality dq = mydatabase.getDataQuality();
  y.setDataQuality(dq);
  boolean ydqp = y.hasDataQuality();    // true
  DataQuality ydq = y.getDataQuality(); // == dq
  
It is expected that most DataQuality instances will be used in may PG
instances, as most databases have the same level of quality for all
information within the database (or perhaps by table).  DQ-aware LDM
plugins should endeavor to reuse DQ instances as often as possible to
reduce the memory overhead of this support.

Below is part of the original DQ design discussion:

>
> Issue 1: Should DQ be a function of the Object or a third-party
> service?  e.g.
> 	DataQuality dq = myasset.getPhysicalPG().getDataQuality();
>   vs
> 	DataQuality dq = theDataQualityServer.getDQ(myasset.getPhysicalPG());

> Answer: people seem more comfortable with the former.

> Issue 2: What decides if a PG can have a DQ assigned to it?
> 	Compile/Build time?  e.g. the properties.def specifies
> 		which PGs have 'em.  This means you can know
> 		apriori which PGs will not have DQ. e.g.  All 
> 		instances of fooPG will support DQ.
> 	Runtime? Any PG may or may not have DQ.  LDM plugin decides on 
> 		a per-instance basis.
> Answer: sounds like Runtime (per-instance choice) is the consensus.

> Issue 3: related to 2, should all PGs implement the interface,
> 	regardless of whether or not they can be set?
> 	If yes, we might as well make DQ part of the PG interface.
> 	If no, we should have a separate interface which some
> 	implement, and some dont.
> Answer: ?

> Issue 4: How should one ask (pragmatically) if a PG has DQ?
> 	instanceof?
> 		if (myPG instanceof PGWithDataQuality) {
> 		  dq = ((PGWithDataQuality) myPG).getDataQuality();
> 		  ...
> 		}
> 	null?
> 		if ((dq = myPG.getDataQuality()) != null) {
> 	 	  ...
> 		}
> 	check?
> 		if (myPG.hasDataQuality()) { 
> 		  dq = myPG.getDataQuality();
> 		  ...
> 		}
> 	non-null constant values:
> 		if ((dq = myPG.getDataQuality()).isValid()) {
> 		  ...
> 		}
> Answer: clearly, the reasonable choice is effected by your choice on
> #3.  Which is least objectionable?  Vote early and often...

