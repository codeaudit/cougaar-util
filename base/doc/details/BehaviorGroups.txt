BehaviorGroups have been implemented as an ability to add complex,
hand-defined methods into machine-generated code via delegation.

The specification has been changed since the original in several
ways:
1. the delegates= directive may take a fully-qualified class name,
	i.e. com.fooco.cougaar.MyDelegate
2. the delegate class may be a class, and abstract class or even an
	interface, since the PG code never actually constructs the
	objects.  In any case, the specified class must still
	implement (or extend, if an interface) the interface
	PGDelegate.
3. PGDelegate continues to require the method copy(PropertyGroup) of
	concrete subclasses.  This is to avoid requiring both Clonable 
	and a specific PG setter method of all implementations.
	A clone of the original PG will use the result of BG.copy(newPG)
	as its BG value.
4. The generated *PGImpl and New*PG code will provide a one-time
	setter method to set the BG instance instead of creating the
	BG instance itself.  This requires that plugins creating a PG
	are required to set all BG delegates or risk NPEs later on.
	An exception will be thrown if a given BG delegate is set more 
	than once.  A symmetric get*BG accessor will also be provided
	for convenience (see the code below).
5. a "<delegate>.auto=true" directive may be used to have the delegate 
	instance created automatically, e.g. at PG construction time.
	If this is done, neither the New<Whatever> interface nor the
	<Whatever>Impl implementation will have delegate getters or setters.
	The default of .auto is false.  Specification of .auto=true
	will give essentially identical behavior to the COUGAAR 6.2 release.

Example:

;!generate: org.cougaar.tools.build.PGWriter
;; my properties.def file

[MyPG]
doc=A property group with standard and active slots
slots=int x, String y, double z
delegates=com.thingco.cougaar.MyDelegate thing
thing.delegate=int computeW(int inc);\
		String prettyString();\
		double checkAsset(Asset a);

/// hand-written myDelegate
// expect it to be Serialized!
package com.thingco.cougaar;
import ...;
class MyDelegate implements PGDelegate {
  private MyPG myPG;
  // this constructor is called by the constructor of MyPG 
  public MyDelegate(MyPG pg) {
    myPG = pg;
  }

  // here are the delegated-to methods
  public int computeW(int i) { return myPG.getX()+i; }
  public String prettyString() { return "("+myPG.getX()+","+myPG.getY()+")"; }
  public double checkAsset(Asset a) {
    return myPG.getZ()*a.getPhysicalPG().getMass().getKilograms();
  }

  // implement PGDelegate
  public PGDelegate copy(PropertyGroup pg) {
    return new MyDelegate((MyPG)pg);
  }
}


// the generated code for MyPG looks something like (simplified):


public final class MyPGImpl
{
  public MyPGImpl() {
    // no longer create an instance for thing.
  };

  // Slots

  private int theX;
  public int getX(){ return theX; }
  public void setX(int x) {
    theX=x;
  }
  private String theY;
  public String getY(){ return theY; }
  public void setY(String y) {
    if (y!=null) y=y.intern();
    theY=y;
  }
  private double theZ;
  public double getZ(){ return theZ; }
  public void setZ(double z) {
    theZ=z;
  }

  private MyDelegate thing = null;
  public int computeW(int inc) {return thing.computeW(inc);  }
  public String prettyString() {return thing.prettyString();  }
  public double checkAsset(Asset a) {return thing.checkAsset(a); }

  // specifed in NewMyPG
  public MyDelegate getThing() { return thing; }
  public void setThing(MyDelegate _thing) {
    if (thing!=null) throw new CalledTwiceException();
    return thing;
  }
}

// an LDM plugin might have the following code:

  void fillAsset(Asset a) {
    // create the property group
    NewMyPG pg = (NewMyPG) ldmf.createPropertyGroup(MyPG.class);
    // create the delegate
    MyDelegate del = new MyDelegate(pg);
    // attach the delegate to the PG
    pg.setThing(del);
    // attach the PG to the asset
    a.setPropertyGroup(pg);
  }
