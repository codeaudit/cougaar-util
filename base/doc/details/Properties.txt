Notes on LDM Properties definition language (properties.def)

* Generic Collection typed properties.

Not only may the declared type of a property be a (Java2) collection
type, but it may also be parameterized with the element type for
additional expressiveness. Example: 

[AssignedPG]
slots= List<Role> roles

This results in classes like:

interface AssignedPG {
  List getRoles();
  boolean inRoles(Role element);
}
interface NewAssignedPG {
  void setRoles(List roles);
  void clearRoles();
  void removeFromRoles(Role element);
  void addToRoles(Roles element);
}

Along with appropriate implementations.  

The syntax is intended to be similar to GenericJava (GJ) which is a
proposal for support of parameterized types in a future version of
official Java.

The default is to allow the LDM Plugins supplying the values to define 
and install the actual collection class.  However, there you can
specify the actual class to contruct (and new properties will do so
automatically) with a directive like:

	roles.init=ArrayList


* ParameterizedProperties Design

There have been several requests for adding the ability for individual 
properties of property groups to be able to take arguments. Two
examples are to support consumption-rate tables on assets, and to allow
properties that take a time parameter.  It is non-trivial for the
LDM infrastructure to support this sort of thing in a modular way that 
avoids dependency on specific LDM plugins.  Following is a description 
of a new facility that allows values of parameterized properties be
supplied by LDM plugins.

* Changes to properties.def

Property "slot" descriptions may now also include arguments.  Example:

[SamplePG]
slots=\
	Mass mass,\
	int matrix(int x, int y)

This will result in interfaces like:

interface SamplePG {
  Mass getMass();
  int getMatrix(int x, int y);

  public interface MatrixHandler {
    int getMatrix(int x, int y);
    void setMatrix(int value, int x, int y);  
  }
}

interface NewSamplePG extends SamplePG {
  void setMass(Mass mass);
  void setMatrix(int value, int x, int y);
  void setMatrixHandler(MatrixHandler handler);
}

The implementation dispatches calls to the matrix getters and setters
to the MatrixHandler instance, presumably provided by an LDM plugin at 
the same time that the Mass slot was set.

Access to an unhandled property results in an UndefinedValueException.

* LDM Plugin implementation

LDM PlugIns may do something like the following:

void fillInProperties(final Asset asset) {
  NewSamplePG pg = ...;
  pg.setMass(db.lookupMass(key));
  
  // make an anonymous inner class instance to handle Matrix
  SamplePG.MatrixHandler mh = 
    new SamplePG.MatrixHandler() {
      // close over asset in the outer class
      public MatrixHandler() {}
      public void setMatrix(int value, int x, int y) { } // ignore setter
      public int getMatrix(int x, int y) {
        // call method in the outer class
        int lookupMatrix(asset, x, y);
      }
    };

  pg.setMatrixHandler(mh);

  // tell the asset about it...
  asset.setSamplePG(pg.lock());
}

int lookupMatrix(Asset a, int x, int y) {
  synchronized (cacheLock) {
    IntMatrix m = checkCache(a);
    if (m == null) {
      m = lookupMatrixInDatabase(a);
      addToCache(a, m);
    }
    return m.get(x, y);
  }
}


The Handler may be a regular class, could be initialized with the
asset (or maybe isn't even asset-indexed in cases where the DB serves
only one asset), or could be a computation based on other property
values.

* Extra features.

Specifying in properties.def something like:
  int hack(),
will result in a zero-argument parameterized property, requiring a
Handler, etc.  This is intended to support call-time evaluation (or
lazy-evaluation) properties, rather than the write-update implied
model of non-parameterized properties.


* Example of a complex property:

;; properties.def:

[SamplePG]
slots=Mass mass, \
	List<Role> roles, \
	int matrix(int x, int y)
weight.doc=The mass of my Asset

;; generated SamplePG.java

public interface SamplePG extends PropertyGroup {
  Mass getMass();
  List getRoles();
  boolean inRoles(Role element);
  int getMatrix(int x, int y);
  public interface MatrixHandler {
    int getMatrix(int x, int y);
    void setMatrix(int _value, int x, int y);
  }
}

;; generated NewSamplePG.java

public interface NewSamplePG extends SamplePG, NewPropertyGroup {
  void setMass(Mass mass);
  void setRoles(List roles);
  void clearRoles();
  boolean removeFromRoles(Role _element);
  boolean addToRoles(Role _element);
  void setMatrix(int _value, int x, int y);
  void setMatrixHandler(MatrixHandler handler);
}

;; generated SamplePGImpl.java

public final class SamplePGImpl implements NewSamplePG, Cloneable {
  public SamplePGImpl() { };
  private Mass theMass;
  public Mass getMass(){ return theMass; }
  public void setMass(Mass mass) { theMass=mass; }
  private List theRoles;
  public List getRoles(){ return theRoles; }
  public boolean inRoles(Role _element) {
    return theRoles.contains(_element);
  }
  public void setRoles(List roles) {
    theRoles=roles;
  }
  public void clearRoles() {
    theRoles.clear();
  }
  public boolean removeFromRoles(Role _element) {
    return theRoles.remove(_element);
  }
  public boolean addToRoles(Role _element) {
    return theRoles.add(_element);
  }
  private transient MatrixHandler theMatrixHandler = null;
  public void setMatrixHandler(MatrixHandler handler) {
    theMatrixHandler = handler;
  }
  public int getMatrix(int x, int y) {
    if (theMatrixHandler==null) throw new UndefinedValueException();
    return theMatrixHandler.getMatrix(x, y);
  }
  public void setMatrix(int _value, int x, int y) {
    if (theMatrixHandler==null) throw new UndefinedValueException();
    theMatrixHandler.setMatrix(_value, x, y);
  }
  SamplePGImpl(SamplePG original) {
    theMass = original.getMass();
    theRoles = original.getRoles();
  }
  // ...
}

;; sample LDM plugin code providing values

void fillInProperties(final Asset asset) {
  NewSamplePG pg = LDMF.createPropertyGroup(SamplePG.class);
  
  double kg = db.lookupMass(key)
  pg.setMass(Mass.newKilograms(kg));
  
  List l = new ArrayList();
  String rs = db.lookupPrimaryRole(key);
  Role role = LDMF.newRole(rs);
  l.add(l);
  pg.setRoles(l);

  // just like example above
  SamplePG.MatrixHandler mh = 
    new SamplePG.MatrixHandler() {
      // close over asset in the outer class
      public MatrixHandler() {}
      public void setMatrix(int value, int x, int y) { } // ignore setter
      public int getMatrix(int x, int y) {
        // call method in the outer class
        int lookupMatrix(asset, x, y);
      }
    };
  pg.setMatrixHandler(mh);

  // attach it to the asset
  asset.setSamplePG(pg);
}
