<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://esb.bbn.com/~rshapiro/message-externalization.html -->
<HTML><HEAD><TITLE>Message Externalization Aspects</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2919.6307" name=GENERATOR></HEAD>
<BODY>
<H1>Message Externalization Aspects</H1>
<OL>
  <LI>
  <H2>Overview</H2>As of 9.2, COUGAAR now provides more fine-grained control 
  over the externalization of AttributedMessages. In particular, a new set of 
  join points has been defined in the interfaces MessageWriter and 
  MessageReader. Attaching Aspect delegates at these interfaces provides the 
  ability to control and/or monitor message externalization. 
  <LI>
  <H2>MessageWriter and MessageReader interfaces</H2>The two new interfaces have 
  a completely symmetric set of methods: 
  <DL>
    <P>
    <DT><I>void finalizeAttributes(AttributedMessage msg)</I> 
    <DD>This method is called before the contents of the message are serialized 
    and provide a hook for Aspect delegates to make adjustments to the 
    messages's attributes just before they're sent (on the writer side) or just 
    after they're read (on the reader side). 
    <P></P>
    <DT><I>void preProcess()</I> 
    <DD>On the sender side, this method is called after the attributes have been 
    sent but before the message body has been sent. On the reader side, it's 
    called after the attributes have been received but before the message body 
    has been received. Any other pre-processing which needs to take place before 
    the creation of the streams and the sending/receiving of the message should 
    take place here. 
    <P></P>
    <DT><I>OutputStream getObjectOutputStream(ObjectOutput out</I>) and 
    <I>InputStream getObjectInputStream(ObjectInput in)</I> 
    <DD>These methods are used to create a nested set of Filter streams thrrough 
    which the body of the message will be sent. The nesting matches the nesting 
    of the Aspect delegates. 
    <P></P>
    <DT><I>void finishOutput()</I> and <I>void finishInput()</I> 
    <DD>These methods are called after the body of the message has been 
    sent/received. Any final i/o cleanup should happen here. 
    <P></P>
    <DT><I>void postProcess()</I> 
    <DD>This method is called after all i/o is complete. Any final cleanup 
    should happen here. </DD></DL>
  <LI>
  <H2>Using Aspects on MessageReader and MessageWriter</H2>In order to allow a 
  message-specific set of filtering streams, an extra level of Aspect selection 
  has been added for MessageReader and MessageWriter. Only those Aspect 
  classname which are include in the AttributedMessage's FILTERS_ATTRIBUTE (see 
  MessageAttributes) will be used for the given message. The implication is the 
  Aspects must decide on a per-message basis whether or not to add their 
  classname to this attribute. This would typically be done in the 
  forwardMessage method on a DestinationLink delegate, before the super call. 
  <P>NB: This will change slightly after 9.2.1. Rather than adding the classname 
  to the FILTERS_ATTRIBUTE, the delegate should invoke addFilter on the 
  AttributedMessage, passing in the Aspect instance as argument. </P>
  <LI>
  <H2>Interface definitions</H2><PRE><CODE>
public interface MessageWriter
{
    void finalizeAttributes(AttributedMessage msg);

    void preProcess();

    // The argument is the next innermost stream in the nesting.
    OutputStream getObjectOutputStream(ObjectOutput out)
	throws java.io.IOException;
 
    void finishOutput()
	throws java.io.IOException;

    void postProcess();
}


public interface MessageReader
{
    
    void finalizeAttributes(AttributedMessage msg);

    void preProcess();

    // The argument is the next innermost stream in the nesting.
    InputStream getObjectInputStream(ObjectInput in) 
	throws java.io.IOException, ClassNotFoundException;

    // Could be reading from a cached stream, so could throw
    // IOException.
    void finishInput()
	throws java.io.IOException;

    void postProcess();

}

</CODE></PRE>
  <LI>
  <H2>Example</H2><PRE><CODE>

package org.cougaar.core.mts;


import java.io.FilterOutputStream;
import java.io.FilterInputStream;
import java.io.ObjectInput;
import java.io.InputStream;
import java.io.ObjectOutput;
import java.io.OutputStream;


public class CountBytesStreamsAspect extends StandardAspect 
{

    // The name of a local attribute which will be used to store the
    // count.
    private static final String COUNT_ATTR =
	"org.cougaar.core.message.count";

    // The name of this class.  We need to add this to the
    // FILTERS_ATTRIBUTE
    private static final String THIS_CLASS =
	"org.cougaar.core.mts.CountBytesStreamsAspect";


    // Return delegates for MessageReader, MessageWriter and
    // DestinationLink.
    public Object getDelegate(Object delegatee, Class type) {
	if (type == MessageWriter.class) {
	    MessageWriter wtr = (MessageWriter) delegatee;
	    return new CountingMessageWriter(wtr);
	} else if (type == MessageReader.class) {
	    MessageReader rdr = (MessageReader) delegatee;
	    return new CountingMessageReader(rdr);
	} else if (type == DestinationLink.class) {
	    DestinationLink link = (DestinationLink) delegatee;
	    // Only RMI is relevant here
	    Class cls = link.getProtocolClass();
	    if (RMILinkProtocol.class.isAssignableFrom(cls))
		return new BandwidthDestinationLink(link);
	}
	 
	return null;
    }



    // The DestinationLink delegate
    private class BandwidthDestinationLink 
	extends DestinationLinkDelegateImplBase
    {
	BandwidthDestinationLink(DestinationLink delegatee) {
	    super(delegatee);
	}


	public MessageAttributes forwardMessage(AttributedMessage message) 
	    throws NameLookupException, 
		   UnregisteredNameException, 
		   CommFailureException,
		   MisdeliveredMessageException
	{
	    // Register Aspect as a Message Streaming filter
 	    message.addValue(MessageAttributes.FILTERS_ATTRIBUTE,
 			     THIS_CLASS);

            // After 9.2.1 this will become
            // message.addFilter(CountBytesStreamAspect.this);



	    // Compute the latency and print it along with the cached
	    // byte count (the MessageWriter will do the actual
	    // counting).
	    long start = System.currentTimeMillis();
	    MessageAttributes reply = super.forwardMessage(message);
	    long elapsed = System.currentTimeMillis()-start;
	    Integer Count = (Integer) message.getAttribute(COUNT_ATTR);
	    if (Count != null) {
		System.out.println(" Message from " +message.getOriginator()+
				   " to " +message.getTarget()+
				   " has " +Count+ " bytes and took " 
				   +elapsed+ " ms");
	    }

	    return reply;
	}
    }


    // The MessageWriter delegate.  This will do the byte-counting by
    // creating a simple FilterOutputStream that watches all the bytes
    // go past,
    private class CountingMessageWriter
	extends MessageWriterDelegateImplBase
    {

	private AttributedMessage msg;
	private int count = 0;

	private class CountingOutputStream extends FilterOutputStream {

	    private CountingOutputStream(OutputStream wrapped) {
		super(wrapped);
	    }


	    // Count the bytes, whichever method is used to write
	    // them.  Pass the byte or bytes to 'out' rather than
	    // using super, since the default FilterOutputStream
	    // methods aren't very efficient.

 	    public void write(int b) throws java.io.IOException {
 		out.write(b);
 		++count;
 	    }

 	    public void write(byte[] b, int off, int len)
		throws java.io.IOException 
	    {
 		out.write(b, off, len);
 		count += len;
 	    }


 	    public void write(byte[] b)
		throws java.io.IOException 
	    {
 		out.write(b);
 		count += b.length;
 	    }

	}

	CountingMessageWriter(MessageWriter delegatee) {
	    super(delegatee);
	}



	// Create and return the byte-counting FilterOutputStream
	public OutputStream getObjectOutputStream(ObjectOutput out)
	    throws java.io.IOException
	{
	    OutputStream raw_os = super.getObjectOutputStream(out);
	    return new CountingOutputStream(raw_os);
	}


	// Save the message, since we'll need it later (in
	// postProcess).
	public void finalizeAttributes(AttributedMessage msg) {
	    super.finalizeAttributes(msg);
	    this.msg = msg;
	}


	// Stash the count in the saved message's attributes.  Note
	// that we're doing this after the message has been sent.
	// Even if it weren't a local attribute, the receive would
	// never see it.  But other aspect delegates can get at it. In
	// fact the DestinationLink delegate above does so.
	public void postProcess() 
	{
	    super.postProcess();
	    if (msg != null) msg.setLocalAttribute(COUNT_ATTR, new Integer(count));
	}
    }



    // MessageReader delegate.  In this case it does nothing.
    // Nonetheless it has to be here, since for reasons we don't yet
    // understand, the filtered streams have to match exactly on the
    // reader and writer.
    private class CountingMessageReader
	extends MessageReaderDelegateImplBase
    {

	// Does absolutely nothing but has to be here.
	private class CountingInputStream extends FilterInputStream {

	    private CountingInputStream(InputStream wrapped) {
		super(wrapped);
	    }

	    public int read() throws java.io.IOException {
		return in.read();
	    }

	    public int read(byte[] b, int off, int len) 
		throws java.io.IOException
	    {
		return in.read(b, off, len);
	    }

	    public int read(byte[] b) 
		throws java.io.IOException
	    {
		return in.read(b);
	    }
	}

	CountingMessageReader(MessageReader delegatee) {
	    super(delegatee);
	}

	public InputStream getObjectInputStream(ObjectInput in)
	    throws java.io.IOException, ClassNotFoundException
	{
	    InputStream raw_is = super.getObjectInputStream(in);
	    return new CountingInputStream(raw_is);
	}
    }



}



</CODE></PRE></LI></OL>
<HR>

<ADDRESS><A href="mailto:rshapiro@bbn.com">R Shapiro</A></ADDRESS><!-- Created: Mon May 13 14:40:08 EDT 2002 --><!-- hhmts start -->Last 
modified: Tue May 14 10:37:40 EDT 2002 <!-- hhmts end --></BODY></HTML>
