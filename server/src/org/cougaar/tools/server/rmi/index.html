<html>
</head><title>Notes on server/rmi code</title></head>
<body>

<font size=+2>Some notes on the <tt>org.cougaar.tools.server.rmi</tt> code:</font>

<p>

<pre>
<font size=+1>Naming convention:</font>
  There are three prefixes:
     "Client*"
     "Server*"
     "External*"  (from org.cougaar.core.society)

  "Client*" code runs on the same JVM as the Console.

  "Server*" code runs on the same JVM as the ServerDaemon, which spawns
  the node processes.

  "External*" code runs on the same JVM as the live Node instance.  The
  only exception is "ExternalNodeActionListener", but this is subclassed
  here as "ServerNodeActionListener", so it too matches the naming convention.

  The real benefit of this naming convention is that it indicates where
  the instances reside v.s. the RMI stubs.  For example, 
  <code>ClientNodeActionListener</code> resides on the "client" JVM, and 
  all "Server*" code that refers to this ClientNodeActionListeneer will get 
  an RMI stub for this "Client*" code.

<font size=+1>More naming conventions:</font>
  "*Impl" are implementation of RMI Remote interfaces.  These must be
  RMI-stubbed with "rmic".  Further, when a "Server*" refers to a "Client*"
  it should only refer to one of these (RMI-Remote) interfaces.
</pre>

<p>

<pre>
<font size=+1>Basic pattern:</font>
  There are "*CommunityController"s, which allow the Console to create Nodes.

  "*NodeController"s allow the Console to contact the Node, control it, and 
  query for information.

  "*NodeActionListener"s allow the Node to push information back to the 
  Console, such as notification that a Node has been destroyed.
</pre>

</body>
</html>
